<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="The CloudNativePG Contributors" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Frequently Asked Questions (FAQ) - CloudNativePG</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Frequently Asked Questions (FAQ)";
        var mkdocs_page_input_path = "faq.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> CloudNativePG
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">CloudNativePG</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../before_you_start/">Before You Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../use_cases/">Use cases</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../architecture/">Architecture</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../installation_upgrade/">Installation and upgrades</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../quickstart/">Quickstart</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../bootstrap/">Bootstrap</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../security/">Security</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../instance_manager/">Postgres instance manager</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../scheduling/">Scheduling</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../resource_management/">Resource management</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../failure_modes/">Failure Modes</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../rolling_update/">Rolling Updates</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../replication/">Replication</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../backup_recovery/">Backup and Recovery</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../postgresql_conf/">PostgreSQL Configuration</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../operator_conf/">Operator configuration</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../storage/">Storage</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../labels_annotations/">Labels and annotations</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../monitoring/">Monitoring</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../logging/">Logging</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../certificates/">Certificates</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../ssl_connections/">Client TLS/SSL Connections</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../applications/">Connecting from an application</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../connection_pooling/">Connection Pooling</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../replica_cluster/">Replica clusters</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../kubernetes_upgrade/">Kubernetes Upgrade</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../expose_pg_services/">Exposing Postgres Services</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../cnpg-plugin/">CloudNativePG Plugin</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../failover/">Automated failover</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../troubleshooting/">Troubleshooting</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../fencing/">Fencing</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../postgis/">PostGIS</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../e2e/">End-to-End Tests</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../container_images/">Container Image Requirements</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../operator_capability_levels/">Operator Capability Levels</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../samples/">Examples</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../commercial_support/">Commercial support</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">Frequently Asked Questions (FAQ)</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#running-postgresql-in-kubernetes">Running PostgreSQL in Kubernetes</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#high-availability">High availability</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#database-management">Database management</a>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../api_reference/">API Reference</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../supported_releases/">Supported releases</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../release_notes/">Release notes</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">CloudNativePG</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" alt="Docs"></a> &raquo;</li><li>Frequently Asked Questions (FAQ)</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>

          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="frequently-asked-questions-faq">Frequently Asked Questions (FAQ)</h1>
<h2 id="running-postgresql-in-kubernetes">Running PostgreSQL in Kubernetes</h2>
<p><strong>Everyone knows that stateful workloads like PostgreSQL cannot run in
Kubernetes. Why do you say the contrary?</strong></p>
<p>An <a href="https://dok.community/dokc-2021-report/"><em>independent research survey commissioned by the Data on Kubernetes
Community</em></a> in September 2021
revealed that half of the respondents run most of their production
workloads on Kubernetes. 90% of them believe that Kubernetes is ready
for stateful workloads, and 70% of them run databases in production.
Databases like Postgres. However, according to them, significant
challenges remain, such as the knowledge gap (Kubernetes and Cloud
Native, in general, have a steep learning curve) and the quality of
Kubernetes operators. The latter is the reason why we believe that an
operator like CloudNativePG highly contributes to the success
of your project.</p>
<p>For database fanatics like us, a real game-changer has been the
introduction of the support for local persistent volumes in
<a href="https://kubernetes.io/blog/2019/04/04/kubernetes-1.14-local-persistent-volumes-ga/"><em>Kubernetes 1.14 in April 2019</em></a>.</p>
<p><strong>CloudNativePG is built on immutable application containers.
What does it mean?</strong></p>
<p>According to the microservice architectural pattern, a container is
designed to run a single application or process. As a result, such
container images are built to run the main application as the
single entry point (the so-called PID 1 process).</p>
<p>In Kubernetes terms, the application is referred to as workload.
Workloads can be stateless like a web application server or stateful like a
database. Mapping this concept to PostgreSQL, an immutable application
container is a single "postgres" process that is running and
tied to a single and specific version - the one in the immutable
container image.</p>
<p>No other processes such as SSH or systemd, or syslog are allowed.</p>
<p>Immutable Application Containers are in contrast with Mutable System
Containers, which are still a very common way to interpret and use
containers.</p>
<p>Immutable means that a container won't be modified during its life: no
updates, no patches, no configuration changes. If you must update the
application code or apply a patch, you build a new image and redeploy
it. Immutability makes deployments safer and more repeatable.</p>
<p>For more information, please refer to
<a href="https://www.enterprisedb.com/blog/why-edb-chose-immutable-application-containers"><em>"Why EDB chose immutable application containers"</em></a>.</p>
<p><strong>What does Cloud Native mean?</strong></p>
<p>The Cloud Native Computing Foundation defines the term
"<a href="https://github.com/cncf/toc/blob/main/DEFINITION.md"><em>Cloud Native</em></a>".
However, since the start of the Cloud Native PostgreSQL/CloudNativePG operator
at 2ndQuadrant, the development team has been interpreting Cloud Native
as three main concepts:</p>
<ol>
<li>An existing, healthy, genuine, and prosperous DevOps culture, founded
    on people, as well as principles and processes, which enables teams
    and organizations (as teams of teams) to continuously change so to
    innovate and accelerate the delivery of outcomes and produce value
    for the business in safer, more efficient, and more engaging ways</li>
<li>A microservice architecture that is based on Immutable Application
    Containers</li>
<li>A way to manage and orchestrate these containers, such as Kubernetes</li>
</ol>
<p>Currently, the standard de facto for container orchestration is
Kubernetes, which automates the deployment, administration and
scalability of Cloud Native Applications.</p>
<p>Another definition of Cloud Native that resonates with us is the one
defined by Ibryam and Huß in
<a href="https://www.oreilly.com/library/view/kubernetes-patterns/9781492050278/"><em>"Kubernetes Patterns", published by O'Reilly</em></a>:</p>
<blockquote>
<p>Principles, Patterns, Tools to automate containerized microservices at scale</p>
</blockquote>
<!--
**Can I run CloudNativePG on bare metal Kubernetes?**

TODO

**Why should I use PostgreSQL replication instead of file system
replication?**

TODO
-->

<p><strong>Why should I use an operator instead of running PostgreSQL as a
container?</strong></p>
<p>The most basic approach to running PostgreSQL in Kubernetes is to have a
pod, which is the smallest unit of deployment in Kubernetes, running a
Postgres container with no replica. The volume hosting the Postgres data
directory is mounted on the pod, and it usually resides on network
storage. In this case, Kubernetes restarts the pod in case of a
problem or moves it to another Kubernetes node.</p>
<p>The most sophisticated approach is to run PostgreSQL using an operator.
An operator is an extension of the Kubernetes controller and defines how
a complex application works in business continuity contexts. The
operator pattern is currently state of the art in Kubernetes for
this purpose. An operator simulates the work of a human operator in an
automated and programmatic way.</p>
<p>Postgres is a complex application, and an operator not only needs to
deploy a cluster (the first step), but also properly react after
unexpected events. The typical example is that of a failover.</p>
<p>An operator relies on Kubernetes for capabilities like self-healing,
scalability, replication, high availability, backup, recovery, updates,
access, resource control, storage management, and so on. It also
facilitates the integration of a PostgreSQL cluster in the log
management and monitoring infrastructure.</p>
<p>CloudNativePG enables the definition of the desired state of a
PostgreSQL cluster via declarative configuration. Kubernetes
continuously makes sure that the current state of the infrastructure
matches the desired one through reconciliation loops initiated by the
Kubernetes controller. If the desired state and the actual state don't
match, reconciliation loops trigger self-healing procedures. That's
where an operator like CloudNativePG comes into play.</p>
<p><strong>You say that CloudNativePG is a fully declarative operator.
What do you mean by that?</strong></p>
<p>The easiest way is to explain declarative configuration through an
example that highlights the differences with imperative configuration.
In an imperative context, the state is defined as a series of tasks to
be executed in sequence. So, we can get a three-node PostgreSQL cluster
by creating the first instance, configuring the replication, cloning a
second instance, and the third one.</p>
<p>In a declarative approach, the state of a system is defined using
configuration, namely: there's a PostgreSQL 13 cluster with two replicas.
This approach highly simplifies change management operations, and when
these are stored in source control systems like Git, it enables the
Infrastructure as Code capability. And Kubernetes takes it farther than
deployment, as it makes sure that our request is fulfilled at any time.</p>
<p><strong>What are the required skills to run PostgreSQL on Kubernetes?</strong></p>
<p>Running PostgreSQL on Kubernetes requires both PostgreSQL and Kubernetes
skills in your DevOps team. The best experience is when database
administrators familiarize themselves with Kubernetes core concepts
and are able to interact with Kubernetes administrators.</p>
<p>Our advice is for everyone that wants to fully exploit Cloud Native
PostgreSQL to acquire the "Certified Kubernetes Administrator (CKA)"
status from the CNCF certification program.</p>
<h2 id="high-availability">High availability</h2>
<p><strong>What happens to the PostgreSQL clusters when the operator pod dies or it is
not available for a certain amount of time?</strong></p>
<p>The CloudNativePG operator, among other things, is responsible for self-healing
capabilities. As such, they might not be available during an outage of the
operator.</p>
<p>However, assuming that the outage does not affect the nodes where PostgreSQL
clusters are running, the database will continue to serve normal operations,
through the relevant Kubernetes services. Moreover, the <a href="../instance_manager/">instance manager</a>,
which runs inside each PostgreSQL pod will still work, making sure that the
database server is up, including accessory services like logging, export of
metrics, continuous archiving of WAL files, etc.</p>
<p>To summarize:</p>
<p>an outage of the operator does not necessarily imply a PostgreSQL
database outage; it's like running a database without a DBA or system
administrator.</p>
<!--
What are the reasons behind CloudNativePG not relying on a failover
management tool like Patroni, repmgr, or Stolon?

TODO

How can I ensure that failover (unplanned) and switchover (planned)
times are within our SLA of 99.995% per year?

TODO

Should I manually resync a former primary with the new one following a
failover?

TODO

What happens if all nodes of PostgreSQL have a failure?

TODO

## Backup and restore

Does CloudNativePG support logical backups with pg_dump?

TODO

What is the recommended setup for the best outcomes in terms of disaster
recovery?

TODO

What happens if the Kubernetes cluster where I was running PostgreSQL is
permanently gone?

TODO


## Miscellaneous

**What are the Kubernetes distributions that CloudNativePG
supports? What's the rationale behind this decision?**

TODO

**Are there performance tests or values for large environments (e.g. \>
4 TB/256 GB/64 cores) ?**

TODO

**Question about LDAP/Active Directory support**

TODO

How can the provisioning of CloudNativePG databases be
automated?

TODO

How can the de-provisioning of CloudNativePG be automated?

TODO

Does CloudNativePG wipe the data directory of PostgreSQL when
a cluster is deleted?

TODO

How are changes of resources (storage/CPU/memory) made to a database
instance during runtime?

TODO

How can I get notified via email after a PostgreSQL cluster has been
successfully created, with details about connection?

TODO

## Updates

How can I perform updates on the underlying Kubernetes nodes?

TODO

Can minor version updates of PostgreSQL be carried out without downtime?

TODO

Can major version upgrades of PostgreSQL be carried out without
downtime?

TODO

-->

<h2 id="database-management">Database management</h2>
<p><strong>Why should I use PostgreSQL?</strong></p>
<p>We believe that PostgreSQL is the equivalent in the database area of
what Linux represents in the operating system space. The current latest
major version of Postgres is version 14, which ships out of the box:</p>
<ul>
<li>native streaming replication, both physical and logical</li>
<li>continuous hot backup and point in time recovery</li>
<li>declarative partitioning for horizontal table partitioning, which is
    a very well-known technique in the database area to improve vertical
    scalability on a single instance</li>
<li>extensibility, with extensions like <a href="../postgis/">PostGIS</a> for geographical
    databases</li>
<li>parallel queries for vertical scalability</li>
<li>JSON support, unleashing the multi-model hybrid database for both
    structured and unstructured data queried via standard SQL</li>
</ul>
<p>And so on ...</p>
<p><strong>How many databases should be hosted in a single PostgreSQL instance?</strong></p>
<p>Our recommendation is to dedicate a single PostgreSQL cluster
(intended as primary and multiple standby servers) to a single database,
entirely managed by a single microservice application. However, by
leveraging the "postgres" superuser, it is possible to create as many
users and databases as desired (subject to the available resources).</p>
<p>The reason for this recommendation lies in the Cloud Native concept,
based on microservices. In a pure microservice architecture, the
microservice itself should own the data it manages exclusively.
These could be flat files, queues, key-value stores, or, in our case, a
PostgreSQL relational database containing both structured and
unstructured data. The general idea is that only the microservice can
access the database, including schema management and migrations.</p>
<p>CloudNativePG has been designed to work this way out of the
box, by default creating an application user and an application database
owned by the aforementioned application user.</p>
<p>Reserving a PostgreSQL instance to a single microservice owned database,
enhances:</p>
<ul>
<li>resource management: in PostgreSQL, CPU, and memory constrained
    resources are generally handled at the instance level, not the
    database level, making it easier to integrate it with Kubernetes
    resource management policies at the pood level</li>
<li>physical continuous backup and Point-In-Time-Recovery (PITR): given
    that PostgreSQL handles continuous backup and recovery at the
    instance level, having one database per instance simplifies PITR
    operations, differentiates retention policy management, and
    increases data protection of backups</li>
<li>application updates: enable each application to decide their update
    policies without impacting other databases owned by different
    applications</li>
<li>database updates: each application can decide which PostgreSQL
    version to use, and independently, when to upgrade to a different
    major version of PostgreSQL and at what conditions (e.g., cutover
    time)</li>
</ul>
<p><strong>Is there an upper limit in database size for not considering Kubernetes?</strong></p>
<p>No, as Kubernetes is no different from virtual machines and bare metal as far
as this is regarded.
Practically, however, it depends on the available resources of your Kubernetes
cluster. Our advice with very large databases (VLDB) is to consider a shared
nothing architecture, where a Kubernetes worker node is dedicated to a single
Postgres instance, with dedicated storage.
We proved that this extreme architectural pattern works when we benchmarked
<a href="https://www.2ndquadrant.com/en/blog/local-persistent-volumes-and-postgresql-usage-in-kubernetes/">running PostgreSQL on bare metal Kubernetes with local persistent
volumes</a>.
A current limitation of CloudNativePG, which will be overcome in future
releases, is the lack of support for tablespaces so that horizontal
partitioning can be easily implemented.</p>
<p><strong>How can I specify a time zone in the PostgreSQL cluster?</strong></p>
<p>PostgreSQL has an extensive support for time zones, as explained in the official
documentation:</p>
<ul>
<li><a href="https://www.postgresql.org/docs/current/datatype-datetime.html">Date time data types</a></li>
<li><a href="https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-TIMEZONE">Client connections config options</a></li>
</ul>
<p>Although time zones can even be used at session, transaction and even as part
of a query in PostgreSQL, a very common way is to set them up globally. With
CloudNativePG you can configure the cluster level time zone in the
<code>spec.postgresql.parameters</code> section as in the following example:</p>
<pre><code class="language-yaml">apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: pg-italy
spec:
  instances: 1

  postgresql:
    parameters:
      timezone: &quot;Europe/Rome&quot;

  storage:
    size: 1Gi
</code></pre>
<p>The time zone can be verified with:</p>
<pre><code class="language-console">$ kubectl exec -ti pg-italy-1 -c postgres -- psql -x -c &quot;SHOW timezone&quot;
-[ RECORD 1 ]---------
TimeZone | Europe/Rome
</code></pre>
<!--
**What is the recommended architecture for best business continuity
outcomes?**

TODO

**What are the global objects such as roles and databases that are
automatically created by CloudNativePG?**

TODO

Q: Support for management of Postgres roles via declarative
configuration

TODO

Q: Support for tablespaces

TODO

Q: GUI

TODO

Q: Monitoring

TODO

Q: Logging

TODO

How can instances be stopped or started?

TODO
-->
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../commercial_support/" class="btn btn-neutral float-left" title="Commercial support"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../api_reference/" class="btn btn-neutral float-right" title="API Reference">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../commercial_support/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../api_reference/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
