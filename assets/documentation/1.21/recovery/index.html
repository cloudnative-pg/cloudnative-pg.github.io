<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="The CloudNativePG Contributors" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Recovery - CloudNativePG</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../css/override.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Recovery";
        var mkdocs_page_input_path = "recovery.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> CloudNativePG
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">CloudNativePG</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../before_you_start/">Before You Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../use_cases/">Use cases</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../architecture/">Architecture</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../installation_upgrade/">Installation and upgrades</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../quickstart/">Quickstart</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../bootstrap/">Bootstrap</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../database_import/">Importing Postgres databases</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../security/">Security</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../instance_manager/">Postgres instance manager</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../scheduling/">Scheduling</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../resource_management/">Resource management</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../failure_modes/">Failure Modes</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../rolling_update/">Rolling Updates</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../replication/">Replication</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../backup/">Backup</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../backup_barmanobjectstore/">Backup on object stores</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../wal_archiving/">WAL archiving</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../backup_volumesnapshot/">Backup on volume snapshots</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">Recovery</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#recovery-from-an-object-store">Recovery from an object store</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#recovery-from-volumesnapshot-objects">Recovery from VolumeSnapshot objects</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#recovery-from-a-backup-object">Recovery from a Backup object</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#additional-considerations">Additional considerations</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point-in-time-recovery-pitr">Point in time recovery (PITR)</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#pitr-from-an-object-store">PITR from an object store</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#pitr-from-volumesnapshot-objects">PITR from VolumeSnapshot Objects</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#recovery-targets">Recovery targets</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#configure-the-application-database">Configure the application database</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#how-recovery-works-under-the-hood">How recovery works under the hood</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#restoring-into-a-cluster-with-a-backup-section">Restoring into a cluster with a backup section</a>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../postgresql_conf/">PostgreSQL Configuration</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../declarative_role_management/">Database Role Management</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../operator_conf/">Operator configuration</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../cluster_conf/">Instance pod configuration</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../storage/">Storage</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../labels_annotations/">Labels and annotations</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../monitoring/">Monitoring</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../logging/">Logging</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../certificates/">Certificates</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../ssl_connections/">Client TLS/SSL connections</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../applications/">Connecting from an application</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../connection_pooling/">Connection pooling</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../replica_cluster/">Replica clusters</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../kubernetes_upgrade/">Kubernetes Upgrade</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../expose_pg_services/">Exposing Postgres Services</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../kubectl-plugin/">Kubectl Plugin</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../failover/">Automated failover</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../troubleshooting/">Troubleshooting</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../fencing/">Fencing</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../declarative_hibernation/">Declarative hibernation</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../postgis/">PostGIS</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../e2e/">End-to-End Tests</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../container_images/">Container Image Requirements</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../operator_capability_levels/">Operator capability levels</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../controller/">Custom Pod Controller</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../samples/">Examples</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../networking/">Networking</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../benchmarking/">Benchmarking</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../commercial_support/">Commercial support</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../faq/">Frequently Asked Questions (FAQ)</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../cloudnative-pg.v1/">API Reference</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../supported_releases/">Supported releases</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../release_notes/">Release notes</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Appendixes</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../appendixes/object_stores/">Appendix A - Common object stores for backups</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">CloudNativePG</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Recovery</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="recovery">Recovery</h1>
<p>In PostgreSQL terminology, recovery is the process of starting a PostgreSQL
instance using a previously taken backup. The PostgreSQL recovery mechanism
is very solid and rich. It also supports Point In Time Recovery, which allows
you to restore a given cluster up to any point in time from the first available
backup in your catalog to the last archived WAL (as you can see, the WAL
archive is mandatory in this case).</p>
<p>In CloudNativePG, recovery cannot be performed "in-place" on an existing
cluster. Recovery is rather a way to bootstrap a new Postgres cluster
starting from an available physical backup.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For details on the <code>bootstrap</code> stanza, please refer to the
<a href="../bootstrap/">"Bootstrap" section</a>.</p>
</div>
<p>The <code>recovery</code> bootstrap mode lets you create a new cluster from an existing
physical base backup, and then reapply the WAL files containing the REDO log
from the archive.</p>
<p>WAL files are pulled from the defined <em>recovery object store</em>.</p>
<p>Base backups may be taken either on object stores, or using volume snapshots
(from version 1.21).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Recovery using volume snapshots had an initial release on 1.20.1. Because of
the amount of progress on the feature for 1.21.0, it is strongly advised
that you upgrade to 1.21.0 or more advanced releases to use volume
snapshots.</p>
</div>
<p>Recovery from a <em>recovery object store</em> can be achieved in two ways:</p>
<ul>
<li>using a recovery object store, that is, a backup of another cluster
  created by Barman Cloud and defined via the <code>barmanObjectStore</code> option
  in the <code>externalClusters</code> section (<em>recommended</em>)</li>
<li>using an existing <code>Backup</code> object in the same namespace (this was the
  only option available before version 1.8.0).</li>
</ul>
<p>Both recovery methods enable either full recovery (up to the last
available WAL) or up to a <a href="#point-in-time-recovery-pitr">point in time</a>.
When performing a full recovery, the cluster can also be started
in replica mode (see <a href="../replica_cluster/">replica clusters</a> for reference).
If using replica mode, make sure that the PostgreSQL configuration
(<code>.spec.postgresql.parameters</code>) of the recovered cluster is
compatible, from a physical replication standpoint, with the original one.</p>
<p>For recovery using volume snapshots:</p>
<ul>
<li>using a consistent set of <code>VolumeSnapshot</code> objects that all belong to the
  same backup, and identified by the same <code>cnpg.io/cluster</code> and
  <code>cnpg.io/backupName</code> labels, then recovering through the <code>volumeSnapshots</code>
  option in the <code>.spec.bootstrap.recovery</code> stanza, as described in
  <a href="#recovery-from-volumesnapshot-objects">"Recovery from <code>VolumeSnapshot</code> objects"</a> below</li>
</ul>
<h2 id="recovery-from-an-object-store">Recovery from an object store</h2>
<p>You can recover from a backup created by Barman Cloud and stored on a supported
object store. Once you have defined the external cluster, including all the
required configuration in the <code>barmanObjectStore</code> section, you need to
reference it in the <code>.spec.recovery.source</code> option. The following example
defines a recovery object store in a blob container in Azure:</p>
<pre><code class="language-yaml">apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: cluster-restore
spec:
  [...]

  superuserSecret:
    name: superuser-secret

  bootstrap:
    recovery:
      source: clusterBackup

  externalClusters:
    - name: clusterBackup
      barmanObjectStore:
        destinationPath: https://STORAGEACCOUNTNAME.blob.core.windows.net/CONTAINERNAME/
        azureCredentials:
          storageAccount:
            name: recovery-object-store-secret
            key: storage_account_name
          storageKey:
            name: recovery-object-store-secret
            key: storage_account_key
        wal:
          maxParallel: 8
</code></pre>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>By default the <code>recovery</code> method strictly uses the <code>name</code> of the
cluster in the <code>externalClusters</code> section as the name of the main folder
of the backup data within the object store, which is normally reserved
for the name of the server. You can specify a different folder name
with the <code>barmanObjectStore.serverName</code> property.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the above example we are taking advantage of the parallel WAL restore
feature, dedicating up to 8 jobs to concurrently fetch the required WAL
files from the archive. This feature can appreciably reduce the recovery time.
Make sure that you plan ahead for this scenario and correctly tune the
value of this parameter for your environment. It will certainly make a
difference <strong>when</strong> (not if) you'll need it.</p>
</div>
<h2 id="recovery-from-volumesnapshot-objects">Recovery from <code>VolumeSnapshot</code> objects</h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When creating replicas after having recovered the primary instance from
the volume snapshot, the operator might end up using <code>pg_basebackup</code>
to synchronize them, resulting in a slower process depending on the size
of the database. This limitation will be lifted in the future when support
for online backups and PVC cloning will be introduced.</p>
</div>
<p>CloudNativePG can create a new cluster from a <code>VolumeSnapshot</code> of a PVC of an
existing <code>Cluster</code> that's been taken using the declarative API for
<a href="../backup_volumesnapshot/">volume snapshot backups</a>.
You will need to specify the name of the snapshot, as in the following example:</p>
<pre><code class="language-yaml">apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: cluster-restore
spec:
  [...]

  bootstrap:
    recovery:
      volumeSnapshots:
        storage:
          name: &lt;snapshot name&gt;
          kind: VolumeSnapshot
          apiGroup: snapshot.storage.k8s.io
</code></pre>
<p>In case the backed-up cluster was using a separate PVC to store the WAL files,
the recovery must include that too:</p>
<pre><code class="language-yaml">apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: cluster-restore
spec:
  [...]

  bootstrap:
    recovery:
      volumeSnapshots:
        storage:
          name: &lt;snapshot name&gt;
          kind: VolumeSnapshot
          apiGroup: snapshot.storage.k8s.io

        walStorage:
          name: &lt;snapshot name&gt;
          kind: VolumeSnapshot
          apiGroup: snapshot.storage.k8s.io
</code></pre>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If bootstrapping a replica-mode cluster from snapshots, to leverage
snapshots for the standby instances and not just the primary,
it would be advisable to:</p>
<ol>
<li>start with a single instance replica cluster. The primary instance will
  be recovered using the snapshot and available WALs form the source cluster</li>
<li>take a snapshot of the primary in the replica cluster</li>
<li>increase the number of instances in the replica cluster as desired</li>
</ol>
</div>
<h2 id="recovery-from-a-backup-object">Recovery from a <code>Backup</code> object</h2>
<p>In case a <code>Backup</code> resource is already available in the namespace in which the
cluster should be created, you can specify its name through
<code>.spec.bootstrap.recovery.backup.name</code>, as in the following example:</p>
<pre><code class="language-yaml">apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: cluster-example-initdb
spec:
  instances: 3

  bootstrap:
    recovery:
      backup:
        name: backup-example

  storage:
    size: 1Gi
</code></pre>
<p>This bootstrap method allows you to specify just a reference to the
backup that needs to be restored.</p>
<p>The previous example implies the application database and its owning user to be
the default one, <code>app</code>. If the PostgreSQL cluster being restored was using
different names, they can be specified as documented in the <a href="#configure-the-application-database">Configure the
application database</a> section.</p>
<h2 id="additional-considerations">Additional considerations</h2>
<p>Whether you recover from a recovery object store, a volume snapshot, or an
existing <code>Backup</code> resource, the following considerations apply:</p>
<ul>
<li>The application database name and the application database user are preserved
  from the backup that is being restored. The operator does not currently attempt
  to back up the underlying secrets, as this is part of the usual maintenance
  activity of the Kubernetes cluster itself.</li>
<li>To preserve the original <code>postgres</code> user password, you need to properly
  configure <code>enableSuperuserAccess</code> and supply a <code>superuserSecret</code>.</li>
<li>By default, the recovery will continue up to the latest
  available WAL on the default target timeline (<code>current</code> for PostgreSQL up to
  11, <code>latest</code> for version 12 and above).
  You can optionally specify a <code>recoveryTarget</code> to perform a point in time
  recovery (see the <a href="#point-in-time-recovery-pitr">"Point in time recovery" section</a>).</li>
</ul>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Consider using the <code>barmanObjectStore.wal.maxParallel</code> option to speed
up WAL fetching from the archive by concurrently downloading the transaction
logs from the recovery object store.</p>
</div>
<h2 id="point-in-time-recovery-pitr">Point in time recovery (PITR)</h2>
<p>Instead of replaying all the WALs up to the latest one, we can ask PostgreSQL
to stop replaying WALs at any given point in time, after having extracted a
base backup. PostgreSQL uses this technique to achieve <em>point-in-time</em> recovery
(PITR). The presence of a WAL archive is mandatory.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>PITR requires you to specify a <strong>recovery target</strong>, by using the options
described in the <a href="#recovery-targets">"Recovery targets" section</a> below.</p>
</div>
<p>The operator will generate the configuration parameters required for this
feature to work in case a recovery target is specified.</p>
<h3 id="pitr-from-an-object-store">PITR from an object store</h3>
<p>The example below uses a recovery object store in Azure that contains both
the base backups and the WAL archive. The recovery target is based on a
requested timestamp:</p>
<pre><code class="language-yaml">apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: cluster-restore-pitr
spec:
  instances: 3

  storage:
    size: 5Gi

  bootstrap:
    recovery:
      # Recovery object store containing WAL archive and base backups
      source: clusterBackup
      recoveryTarget:
        # Time base target for the recovery
        targetTime: &quot;2023-08-11 11:14:21.00000+02&quot;

  externalClusters:
    - name: clusterBackup
      barmanObjectStore:
        destinationPath: https://STORAGEACCOUNTNAME.blob.core.windows.net/CONTAINERNAME/
        azureCredentials:
          storageAccount:
            name: recovery-object-store-secret
            key: storage_account_name
          storageKey:
            name: recovery-object-store-secret
            key: storage_account_key
        wal:
          maxParallel: 8
</code></pre>
<p>You might have noticed that in the above example you only had to specify
the <code>targetTime</code> in the form of a timestamp, without having to worry about
specifying the base backup from which to start the recovery.</p>
<p>The <code>backupID</code> option is the one that allows you to specify the base backup
from which to initiate the recovery process. By default, this value is
empty.</p>
<p>If you assign a value to it (in the form of a Barman backup ID), the operator
will use that backup as base for the recovery.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>You need to make sure that such a backup exists and is accessible.</p>
</div>
<p>If the backup ID is not specified, the operator will automatically detect the
base backup for the recovery as follows:</p>
<ul>
<li>when you use <code>targetTime</code> or <code>targetLSN</code>, the operator selects the closest
  backup that was completed before that target</li>
<li>otherwise the operator selects the last available backup in chronological
  order.</li>
</ul>
<h3 id="pitr-from-volumesnapshot-objects">PITR from <code>VolumeSnapshot</code> Objects</h3>
<p>The example below uses:</p>
<ul>
<li>a Kubernetes volume snapshot for the <code>PGDATA</code> containing the base backup from
  which to start the recovery process, identified in the
  <code>recovery.volumeSnapshots</code> section and called <code>test-snapshot-1</code></li>
<li>a recovery object store in MinIO containing the WAL archive, identified by
  the <code>recovery.source</code> option in the form of an external cluster definition</li>
</ul>
<p>The recovery target is based on a requested timestamp.</p>
<pre><code class="language-yaml">apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: cluster-example-snapshot
spec:
  # ...
  bootstrap:
    recovery:
      source: cluster-example-with-backup
      volumeSnapshots:
        storage:
          name: test-snapshot-1
          kind: VolumeSnapshot
          apiGroup: snapshot.storage.k8s.io
      recoveryTarget:
        targetTime: &quot;2023-07-06T08:00:39&quot;
  externalClusters:
    - name: cluster-example-with-backup
      barmanObjectStore:
        destinationPath: s3://backups/
        endpointURL: http://minio:9000
        s3Credentials:
          accessKeyId:
            name: minio
            key: ACCESS_KEY_ID
          secretAccessKey:
            name: minio
            key: ACCESS_SECRET_KEY
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In case the backed up Cluster had <code>walStorage</code> enabled, you also must
specify the volume snapshot containing the <code>PGWAL</code> directory, as mentioned
in the <a href="#recovery-from-volumesnapshot-objects">Recovery from VolumeSnapshot objects</a>
section.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is your responsibility to ensure that the end time of the base backup in
the volume snapshot is prior to the recovery target timestamp.</p>
</div>
<h3 id="recovery-targets">Recovery targets</h3>
<p>Here are the recovery target criteria you can use:</p>
<dl>
<dt>targetTime</dt>
<dd>time stamp up to which recovery will proceed, expressed in
   <a href="https://datatracker.ietf.org/doc/html/rfc3339">RFC 3339</a> format
   (the precise stopping point is also influenced by the <code>exclusive</code> option)</dd>
<dt>targetXID</dt>
<dd>transaction ID up to which recovery will proceed
   (the precise stopping point is also influenced by the <code>exclusive</code> option);
   keep in mind that while transaction IDs are assigned sequentially at
   transaction start, transactions can complete in a different numeric order.
   The transactions that will be recovered are those that committed before
   (and optionally including) the specified one</dd>
<dt>targetName</dt>
<dd>named restore point (created with <code>pg_create_restore_point()</code>) to which
   recovery will proceed</dd>
<dt>targetLSN</dt>
<dd>LSN of the write-ahead log location up to which recovery will proceed
   (the precise stopping point is also influenced by the <code>exclusive</code> option)</dd>
<dt>targetImmediate</dt>
<dd>recovery should end as soon as a consistent state is reached - i.e. as early
   as possible. When restoring from an online backup, this means the point where
   taking the backup ended</dd>
</dl>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>While the operator is able to automatically retrieve the closest backup
when either <code>targetTime</code> or <code>targetLSN</code> is specified, this is not possible
for the remaining targets: <code>targetName</code>, <code>targetXID</code>, and <code>targetImmediate</code>.
In such cases, it is important to specify <code>backupID</code>, unless you are OK with
the last available backup in the catalog.</p>
</div>
<p>The example below uses a <code>targetName</code> based recovery target:</p>
<pre><code class="language-yaml">apiVersion: postgresql.cnpg.io/v1
kind: Cluster
[...]
  bootstrap:
    recovery:
      source: clusterBackup
      recoveryTarget:
        backupID: 20220616T142236
        targetName: 'restore_point_1'
[...]
</code></pre>
<p>You can choose only a single one among the targets above in each
<code>recoveryTarget</code> configuration.</p>
<p>Additionally, you can specify <code>targetTLI</code> force recovery to a specific
timeline.</p>
<p>By default, the previous parameters are considered to be inclusive, stopping
just after the recovery target, matching <a href="https://www.postgresql.org/docs/current/runtime-config-wal.html#GUC-RECOVERY-TARGET-INCLUSIVE">the behavior in PostgreSQL</a>
You can request exclusive behavior,
stopping right before the recovery target, by setting the <code>exclusive</code> parameter to
<code>true</code> like in the following example relying on a blob container in Azure
for both base backups and the WAL archive:</p>
<pre><code class="language-yaml">apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: cluster-restore-pitr
spec:
  instances: 3

  storage:
    size: 5Gi

  bootstrap:
    recovery:
      source: clusterBackup
      recoveryTarget:
        backupID: 20220616T142236
        targetName: &quot;maintenance-activity&quot;
        exclusive: true

  externalClusters:
    - name: clusterBackup
      barmanObjectStore:
        destinationPath: https://STORAGEACCOUNTNAME.blob.core.windows.net/CONTAINERNAME/
        azureCredentials:
          storageAccount:
            name: recovery-object-store-secret
            key: storage_account_name
          storageKey:
            name: recovery-object-store-secret
            key: storage_account_key
        wal:
          maxParallel: 8
</code></pre>
<h2 id="configure-the-application-database">Configure the application database</h2>
<p>For the recovered cluster, we can configure the application database name and
credentials with additional configuration. To update application database
credentials, we can generate our own passwords, store them as secrets, and
update the database use the secrets. Or we can also let the operator generate a
secret with randomly secure password for use. Please reference the
<a href="../bootstrap/#bootstrap-an-empty-cluster-initdb">"Bootstrap an empty cluster"</a>
section for more information about secrets.</p>
<p>The following example configure the application database <code>app</code> with owner
<code>app</code>, and supplied secret <code>app-secret</code>.</p>
<pre><code class="language-yaml">apiVersion: postgresql.cnpg.io/v1
kind: Cluster
[...]
spec:
  bootstrap:
    recovery:
      database: app
      owner: app
      secret:
        name: app-secret
      [...]
</code></pre>
<p>With the above configuration, the following will happen after recovery is completed:</p>
<ol>
<li>if database <code>app</code> does not exist, a new database <code>app</code> will be created.</li>
<li>if user <code>app</code> does not exist, a new user <code>app</code> will be created.</li>
<li>if user <code>app</code> is not the owner of database, user <code>app</code> will be granted
as owner of database <code>app</code>.</li>
<li>If value of <code>username</code> match value of <code>owner</code> in secret, the password of
application database will be changed to the value of <code>password</code> in secret.</li>
</ol>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>For a replica cluster with replica mode enabled, the operator will not
create any database or user in the PostgreSQL instance, as these will be
recovered from the original cluster.</p>
</div>
<h2 id="how-recovery-works-under-the-hood">How recovery works under the hood</h2>
<!-- TODO: do we need this section? -->

<p>You can use the data uploaded to the object storage to <em>bootstrap</em> a
new cluster from a previously taken backup.
The operator will orchestrate the recovery process using the
<code>barman-cloud-restore</code> tool (for the base backup) and the
<code>barman-cloud-wal-restore</code> tool (for WAL files, including parallel support, if
requested).</p>
<p>For details and instructions on the <code>recovery</code> bootstrap method, please refer
to the <a href="../bootstrap/#bootstrap-from-a-backup-recovery">"Bootstrap from a backup" section</a>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>If you are not familiar with how <a href="https://www.postgresql.org/docs/current/continuous-archiving.html#BACKUP-PITR-RECOVERY">PostgreSQL PITR</a>
works, we suggest that you configure the recovery cluster as the original
one when it comes to <code>.spec.postgresql.parameters</code>. Once the new cluster is
restored, you can then change the settings as desired.</p>
</div>
<p>Under the hood, the operator will inject an init container in the first
instance of the new cluster, and the init container will start recovering the
backup from the object storage.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The duration of the base backup copy in the new PVC depends on
the size of the backup, as well as the speed of both the network and the
storage.</p>
</div>
<p>When the base backup recovery process is completed, the operator starts the
Postgres instance in recovery mode: in this phase, PostgreSQL is up, albeit not
able to accept connections, and the pod is healthy according to the
liveness probe. Through the <code>restore_command</code>, PostgreSQL starts fetching WAL
files from the archive (you can speed up this phase by setting the
<code>maxParallel</code> option and enable the parallel WAL restore capability).</p>
<p>This phase terminates when PostgreSQL reaches the target (either the end of the
WAL or the required target in case of Point-In-Time-Recovery). Indeed, you can
optionally specify a <code>recoveryTarget</code> to perform a point in time recovery. If
left unspecified, the recovery will continue up to the latest available WAL on
the default target timeline (<code>current</code> for PostgreSQL up to 11, <code>latest</code> for
version 12 and above).</p>
<p>Once the recovery is complete, the operator will set the required
superuser password into the instance. The new primary instance will start
as usual, and the remaining instances will join the cluster as replicas.</p>
<p>The process is transparent for the user and it is managed by the instance
manager running in the Pods.</p>
<h2 id="restoring-into-a-cluster-with-a-backup-section">Restoring into a cluster with a backup section</h2>
<!-- TODO: do we need this section? -->

<p>A manifest for a cluster restore may include a <code>backup</code> section.
This means that the new cluster, after recovery, will start archiving WAL's and
taking backups if configured to do so.</p>
<p>For example, the section below could be part of a manifest for a Cluster
bootstrapping from Cluster <code>cluster-example-backup</code>, and would create a
new folder in the storage bucket named <code>recoveredCluster</code> where the base backups
and WAL's of the recovered cluster would be stored.</p>
<pre><code class="language-yaml">  backup:
    barmanObjectStore:
      destinationPath: s3://backups/
      endpointURL: http://minio:9000
      serverName: &quot;recoveredCluster&quot;
      s3Credentials:
        accessKeyId:
          name: minio
          key: ACCESS_KEY_ID
        secretAccessKey:
          name: minio
          key: ACCESS_SECRET_KEY
    retentionPolicy: &quot;30d&quot;

  externalClusters:
  - name: cluster-example-backup
    barmanObjectStore:
      destinationPath: s3://backups/
      endpointURL: http://minio:9000
      s3Credentials:
</code></pre>
<p>You should not re-use the exact same <code>barmanObjectStore</code> configuration
for different clusters. There could be cases where the existing information
in the storage buckets could be overwritten by the new cluster.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The operator includes a safety check to ensure a cluster will not
overwrite a storage bucket that contained information. A cluster that would
overwrite existing storage will remain in state <code>Setting up primary</code> with
Pods in an Error state.
The pod logs will show:
<code>ERROR: WAL archive check failed for server recoveredCluster: Expected empty archive</code></p>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>If you set the <code>cnpg.io/skipEmptyWalArchiveCheck</code> annotation to <code>enabled</code> in
the recovered cluster, you can skip the above check. This is not recommended
as for the general use case the above check works fine. Please don't do
this unless you are familiar with PostgreSQL recovery system, as this can lead
you to severe data loss.</p>
</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../backup_volumesnapshot/" class="btn btn-neutral float-left" title="Backup on volume snapshots"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../postgresql_conf/" class="btn btn-neutral float-right" title="PostgreSQL Configuration">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../backup_volumesnapshot/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../postgresql_conf/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
